# Prig
## SYNOPSIS
Prig is a lightweight framework for test indirections in .NET Framework.



## DESCRIPTION
Prig(PRototyping jIG) is a framework that generates a [Test Double](http://martinfowler.com/bliki/TestDouble.html) like [Microsoft Fakes](http://msdn.microsoft.com/en-us/library/hh549175.aspx)/[Typemock Isolator](http://www.typemock.com/isolator-product-page)/[Telerik JustMock](http://www.telerik.com/products/mocking.aspx) based on Unmanaged Profiler APIs.
This framework enables that any methods are replaced with mocks. For example, a static property, a private method, a non-virtual member and so on.



## STATUS
As of May 31, 2014, Prig does not work completely. However, we steadily continue to develop at the private repository. This framework will come out within the year if everything goes well.



## QUICK TOUR
Let's say you want to test the following code: 
```cs
using System;

namespace program1.MyLibrary
{
    public static class LifeInfo
    {
        public static bool IsNowLunchBreak()
        {
            var now = DateTime.Now;
            return 12 <= now.Hour && now.Hour < 13;
        }
    }
}
```
You probably can't test this code, because `DateTime.Now` returns the value that depends on an external environment. To make be testable, you should replace `DateTime.Now` to the Test Double that returns the fake information. If you use Prig, it will enable you to generate a Test Double by the following steps without any editing the product code:


### Step 1: Make Stub Settings
Make the following stub settings: 
```xml
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  
  <configSections>
    <section name="prig" type="Urasandesu.Prig.Framework.PilotStubberConfiguration.PrigSection, Urasandesu.Prig.Framework" />
  </configSections>

  <!-- 
      The content of tag 'RuntimeMethodInfo' is generated by NetDataContractSerializer.WriteObject(without explicit assembly version).
      Specifically, you can generate it by the following PowerShell script: 
      
      ========================== EXAMPLE ==========================
      PS C:\> $methods = @([Type]::GetType('System.DateTime').GetMethods(([System.Reflection.BindingFlags]'Public, NonPublic, Static, Instance')) | ? { $_.Name -eq 'get_Now' })
      PS C:\> $methods | % { $_.ToString() }
      System.DateTime get_Now()
      PS C:\> $methods[0] | & .\Invoke-NetDataContractSerializer.ps1 | & clip
      PS C:\>
      
      Then, paste the clipboard content to between 'add' tags.
  -->
  <prig>

    <stubs>
      <!--
      <add name="$(This attribute is identifier. It's preferable that method's overloads can be recognized. If the method has just one signature, this can make be same as 'alias'.)" 
           alias="$(This attribute is an alias as its name suggests. You can use it in your test code.)">
        $(Paste the result of 'Invoke-NetDataContractSerializer.ps1' here.)
      </add>
      -->
      
      <add name="NowGet" alias="NowGet">
        <RuntimeMethodInfo xmlns:i="http://www.w3.org/2001/XMLSchema-instance" xmlns:x="http://www.w3.org/2001/XMLSchema" z:Id="1" z:FactoryType="MemberInfoSerializationHolder" z:Type="System.Reflection.MemberInfoSerializationHolder" z:Assembly="0" xmlns:z="http://schemas.microsoft.com/2003/10/Serialization/" xmlns="http://schemas.datacontract.org/2004/07/System.Reflection">
          <Name z:Id="2" z:Type="System.String" z:Assembly="0" xmlns="">get_Now</Name>
          <AssemblyName z:Id="3" z:Type="System.String" z:Assembly="0" xmlns="">mscorlib</AssemblyName>
          <ClassName z:Id="4" z:Type="System.String" z:Assembly="0" xmlns="">System.DateTime</ClassName>
          <Signature z:Id="5" z:Type="System.String" z:Assembly="0" xmlns="">System.DateTime get_Now()</Signature>
          <Signature2 z:Id="6" z:Type="System.String" z:Assembly="0" xmlns="">System.DateTime get_Now()</Signature2>
          <MemberType z:Id="7" z:Type="System.Int32" z:Assembly="0" xmlns="">8</MemberType>
          <GenericArguments i:nil="true" xmlns="" />
        </RuntimeMethodInfo>
      </add>
    </stubs>
    
  </prig>

</configuration>
```
NOTE: 
* In the release package, you can see full template in `Urasandesu.Prig.Framework\PilotStubber.prig.template`.


### Step 2: Generate Stub
Then, run Developer Command Prompt for VS2013, and invoke PowerShell script `Invoke-PilotStubber.ps1` to generate stub: 
```dos
CMD Test.program1>cd
C:\Prig\Test.program1

CMD Test.program1>"%windir%\system32\WindowsPowerShell\v1.0\powershell.exe" -Version 2.0 -NoLogo -NoProfile
PS Test.program1> $ReferenceFrom = @("C:\Prig\Release(.NET 3.5)\AnyCPU\Urasandesu.Prig.Framework.dll")
PS Test.program1> $Assembly = "mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
PS Test.program1> $TargetFrameworkVersion = "v3.5"
PS Test.program1> $KeyFile = "C:\Prig\Test.program1\Test.program1.snk"
PS Test.program1> $OutputPath = "C:\Prig\Test.program1\bin\Release(.NET 3.5)\x86\"
PS Test.program1> $Settings = "C:\Prig\Test.program1\mscorlib.prig"
PS Test.program1> & "C:\Prig\Release(.NET 3.5)\AnyCPU\Invoke-PilotStubber.ps1" -ReferenceFrom $ReferenceFrom -Assembly $Assembly -TargetFrameworkVersion $TargetFrameworkVersion -KeyFile $KeyFile -OutputPath $OutputPath -Settings $Settings
Microsoft (R) Build Engine Version 12.0.30110.0
[Microsoft .NET Framework, Version 4.0.30319.34014]
Copyright (C) Microsoft Corporation. All rights reserved.

Build started 2014/05/18 16:22:51.
Project "C:\Prig\Test.program1\mscorlib.v2.0.50727.v2.0.0.0.x86.Prig\mscorlib.Prig.g.csproj" on node 1 (rebuild target(s)).
CoreClean:
...

Done Building Project "C:\Prig\Test.program1\mscorlib.v2.0.50727.v2.0.0.0.x86.Prig\mscorlib.Prig.g.csproj" (rebuild target(s)).


Build succeeded.
    0 Warning(s)
    0 Error(s)

Time Elapsed 00:00:00.35
PS Test.program1> exit

CMD Test.program1>

```
NOTE: 
* Actually, I think that typing the command each time is troublesome. So, I recommend that you embed the script to the pre-build event on *.csproj. If you want to create configurations of each .NET Framework version or processor architecture, see also `Test.program1\Test.program1.csproj` in the release pachage.


### Step 3: Make Tests
Make a new class library for unit test, and add the stub dll reference to it.
In the test code, it become testable through the use of the stub and the replacement to Test Double that returns the fake information.
```cs
using NUnit.Framework;
using program1.MyLibrary;
using System;
using System.Prig;
using Urasandesu.Prig.Framework;

namespace Test.program1.MyLibraryTest
{
    [TestFixture]
    public class LifeInfoTest
    {
        [Test]
        public void IsNowLunchBreak_should_return_false_when_11_oclock()
        {
            using (new IndirectionsContext())
            {
                // Arrange
                PDateTime.NowGet.Body = () => new DateTime(2013, 12, 13, 11, 00, 00);

                // Act
                var result = LifeInfo.IsNowLunchBreak();

                // Assert
                Assert.IsFalse(result);
            }
        }

        [Test]
        public void IsNowLunchBreak_should_return_true_when_12_oclock()
        {
            using (new IndirectionsContext())
            {
                // Arrange
                PDateTime.NowGet.Body = () => new DateTime(2013, 12, 13, 12, 00, 00);

                // Act
                var result = LifeInfo.IsNowLunchBreak();

                // Assert
                Assert.IsTrue(result);
            }
        }

        [Test]
        public void IsNowLunchBreak_should_return_false_when_13_oclock()
        {
            using (new IndirectionsContext())
            {
                // Arrange
                PDateTime.NowGet.Body = () => new DateTime(2013, 12, 13, 13, 00, 00);

                // Act
                var result = LifeInfo.IsNowLunchBreak();

                // Assert
                Assert.IsFalse(result);
            }
        }
    }
}
```


### Step 4: Run Tests
In fact, to enable any profiler based mocking tool, you has to set the environment variables. Microsoft Fakes/Typemock Isolator/Telerik JustMock provides the small runner it required, it is true at Prig. So use `prig.exe` to run the test as follows: 
```dos
CMD x86>cd
C:\Prig\Test.program1\bin\Release(.NET 3.5)\x86

CMD x86>"..\..\..\..\Release\x86\prig.exe" run -process "C:\Program Files (x86)\NUnit 2.6.3\bin\nunit-console-x86.exe" -arguments "Test.program1.dll /domain=None"
NUnit-Console version 2.6.3.13283
Copyright (C) 2002-2012 Charlie Poole.
Copyright (C) 2002-2004 James W. Newkirk, Michael C. Two, Alexei A. Vorontsov.
Copyright (C) 2000-2002 Philip Craig.
All Rights Reserved.

Runtime Environment -
   OS Version: Microsoft Windows NT 6.2.9200.0
  CLR Version: 2.0.50727.8000 ( Net 3.5 )

ProcessModel: Default    DomainUsage: None
Execution Runtime: net-3.5
..........
Tests run: 10, Errors: 0, Failures: 0, Inconclusive: 0, Time: 1.44990184322627 seconds
  Not run: 0, Invalid: 0, Ignored: 0, Skipped: 0


CMD x86>
```


### Final Step: Refactoring and Get Trig!
If tests have been created, you can refactor illimitably! For example, you probably can find the result of refactoring as follows: 
```cs
using System;

namespace program1.MyLibrary
{
    public static class LifeInfo
    {
        public static bool IsNowLunchBreak()
        {
            return DateTime.Now.Hour == 12; // Better this way, isn't it?
        }
    }
}
```
As just described, Prig helps the code that depends on an untestable library get trig. I guarantee you will enjoy your development again!!



# INSTALLATION FROM BINARY
## DEPENDENCY
* [NUnit 2.6.3.13283](http://www.nunit.org/)  
Install using with the installer(NUnit-2.6.3.msi).



## REGISTRATION
Run Developer Command Prompt for VS2013 as Administrator, and register dlls that were output to `$(SolutionDir)$(Configuration)\$(PlatformTarget)\` to registry and GAC as follows(these are the examples for x86/.NET 3.5, but also another environments are in the same manner): 
```dos
CMD x86>cd
C:\Prig\Release\x86

CMD x86>regsvr32 /i Urasandesu.Prig.dll

CMD x86>cd "..\..\Release(.NET 3.5)\AnyCPU"

CMD AnyCPU>cd
C:\Prig\Release(.NET 3.5)\AnyCPU

CMD AnyCPU>gacutil /i Urasandesu.NAnonym.dll
Microsoft (R) .NET Global Assembly Cache Utility.  Version 4.0.30319.33440
Copyright (c) Microsoft Corporation.  All rights reserved.

Assembly successfully added to the cache

CMD AnyCPU>gacutil /i Urasandesu.Prig.Framework.dll
Microsoft (R) .NET Global Assembly Cache Utility.  Version 4.0.30319.33440
Copyright (c) Microsoft Corporation.  All rights reserved.

Assembly successfully added to the cache

CMD AnyCPU>
```



## UNREGISTRATION
Unregistration operation is similar in the registration. Run Developer Command Prompt for VS2013 as Administrator and execute the following commands: 
```dos
CMD x86>cd
C:\Prig\Release\x86

CMD x86>regsvr32 /u Urasandesu.Prig.dll

CMD x86>cd "..\..\Release(.NET 3.5)\AnyCPU"

CMD AnyCPU>cd
C:\Prig\Release(.NET 3.5)\AnyCPU

CMD AnyCPU>gacutil /u "Urasandesu.Prig.Framework, Version=0.1.0.0, Culture=neutral, PublicKeyToken=acabb3ef0ebf69ce, processorArchitecture=MSIL"
Microsoft (R) .NET Global Assembly Cache Utility.  Version 4.0.30319.33440
Copyright (c) Microsoft Corporation.  All rights reserved.


Assembly: Urasandesu.Prig.Framework, Version=0.1.0.0, Culture=neutral, PublicKeyToken=acabb3ef0ebf69ce, processorArchitecture=MSIL
Uninstalled: Urasandesu.Prig.Framework, Version=0.1.0.0, Culture=neutral, PublicKeyToken=acabb3ef0ebf69ce, processorArchitecture=MSIL
Number of items uninstalled = 1
Number of failures = 0

CMD AnyCPU>gacutil /u "Urasandesu.NAnonym, Version=0.2.0.0, Culture=neutral, PublicKeyToken=ce9e95b04334d5fb, processorArchitecture=MSIL"
Microsoft (R) .NET Global Assembly Cache Utility.  Version 4.0.30319.33440
Copyright (c) Microsoft Corporation.  All rights reserved.


Assembly: Urasandesu.NAnonym, Version=0.2.0.0, Culture=neutral, PublicKeyToken=ce9e95b04334d5fb, processorArchitecture=MSIL
Uninstalled: Urasandesu.NAnonym, Version=0.2.0.0, Culture=neutral, PublicKeyToken=ce9e95b04334d5fb, processorArchitecture=MSIL
Number of items uninstalled = 1
Number of failures = 0

CMD AnyCPU>
```



# INSTALLATION FROM SOURCE CODE
## DEPENDENCY
To build this project needs the following dependencies: 
* [Visual Studio 2013(more than Professional Edition)](http://www.visualstudio.com/)
* [Boost 1.55.0](http://www.boost.org/)  
Extract to C:\boost_1_55_0, and will build with the following options(x86 and x64 libs are required):
```dos
CMD boost_1_55_0>cd
C:\boost_1_55_0

CMD boost_1_55_0>bootstrap.bat
Building Boost.Build engine

Bootstrapping is done. To build, run:

    .\b2

To adjust configuration, edit 'project-config.jam'.
Further information:
...

CMD boost_1_55_0>.\b2 link=static threading=multi variant=debug,release runtime-link=shared,static -j 4

Building the Boost C++ Libraries.

Performing configuration checks
...

CMD boost_1_55_0>.\b2 link=static threading=multi variant=debug,release runtime-link=shared,static -j 4 --stagedir=.\stage\x64 address-model=64

Building the Boost C++ Libraries.

Performing configuration checks
...
```
* [Google Test 1.6](https://code.google.com/p/googletest/)  
Extract to C:\gtest-1.6.0, and upgrade C:\gtest-1.6.0\msvc\gtest.sln to Visual Studio 2013. Choose the `Build` menu, and open `Configuration Manager...`. On `Configuration Manager` dialog box, in the `Active Solution Platform` drop-down list, select the `<New...>` option. After the `New Solution Platform` dialog box is opened, in the `Type or select the new platform` drop-down list, select a 64-bit platform. Then build all(Debug/Release) configurations.
* [NUnit 2.6.3.13283](http://www.nunit.org/)  
If you haven't taken necessary steps for INSTALLATION FROM BINARY, install using with the installer(NUnit-2.6.3.msi).



## BUILD
After preparing all dependencies, you can build this project in the following steps:

1. Run Visual Studio as Administrator, and open Prig.sln(This sln contains some ATL projects, so the build process will modify registry).
2. According to the version of the product to use, change the solution configuration and the solution platform and build.
3. The results are output to `$(SolutionDir)$(Configuration)\$(PlatformTarget)\`.
4. Proceed the steps of INSTALLATION FROM BINARY.



